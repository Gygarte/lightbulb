import uuid
import functools
from typing import Literal
from dataclasses import dataclass, field
import pandas as pd


@dataclass
class BaseData:
    """
    Base class for all data structures.
    This class can be extended to create specific data models.
    """

    name: str
    version: str
    owner: str
    description: str
    status: Literal["Active", "Draft", "Archived"]
    creation_date: str
    data: pd.DataFrame
    index: tuple[str, str]

    id: int = None  # Unique identifier for the model, is auto-generated

    def __post_init__(self):
        # Checks if the attribute is set - permits loading the model from the database
        if self.id is None:
            self.id = uuid.uuid4().int

    def __init_subclass__(cls, **kwargs):
        """
        This method is called when a subclass is created.
        It ensures that the parent __post_init__ method is not overridden in subclasses.
        """

        if hasattr(super, "__init_subclass__"):
            super().__init_subclass__(**kwargs)

        if "__post_init__" in cls.__dict__:
            original__post_init__ = cls.__post_init__

            @functools.wraps(original__post_init__)
            def wrapped_post_init(cls):
                # Calls the parent class's __post_init__ method
                if hasattr(super(), "__post_init__"):
                    super().__post__init__()
                # Calls the child __post_init__ method
                original__post_init__(cls)

            cls.__post_init__ = wrapped_post_init

    def as_dict(self) -> dict:
        """
        Convert the data model to a dictionary.
        This method is useful for serialization or database storage.
        """
        return {
            "name": self.name,
            "version": self.version,
            "owner": self.owner,
            "description": self.description,
            "status": self.status,
            "creation_date": self.creation_date,
            "data": self.data.to_dict(),
            "index": self.index,
            "id": self.id,
        }

    def __str__(self) -> None:
        """
        String representation of the data model.
        """
        return f"{self.__class__.__name__}()"


@dataclass
class BaseModel:
    """
    Base class for all model in the toolkit.
    """

    # Identification attributes
    # id:str # Unique identifier for the model, is auto-generated
    name: str
    version: str
    owner: str
    status: Literal["Active", "Draft", "Archived"]
    type: Literal["OLS", "Logistic"]
    calibration_date: str
    description: str

    # Model attributes existent at model creation
    # model:object # The model object, e.g., OLS model
    exog: str
    endog: list[str]
    train_interval: tuple[str, str] = None  # took from train data
    test_interval: tuple[str, str] = None  # took from test data
    predict_interval: tuple[str, str] = None  # took from train data

    # Model attributes generated during model usage
    # All the refs attributes are the unique ids of the data objects
    # stored in the database.
    # The reference to the train dataset is unique as only one
    # training dataset can exist per model
    ref_train: int = None
    # Reference to other test data
    ref_test: list[int] = field(default_factory=list)
    # Reference to other forecast data
    ref_forecast: list[int] = field(default_factory=list)
    # Reference to other prediction generated by the model
    ref_prediction: list[int] = field(default_factory=list)

    id: int = None  # Unique identifier for the model, is auto-generated

    def __post_init__(self) -> None:
        """
        Defines operations related to setting up certain attributes and performing checks
        after initialization.
        """
        # Validate the class attributes
        self._checks()
        # Generate the unique identifier for the model
        # Checks if the attribute is set - permits loading the model from the database
        if self.id is None:
            self.id = uuid.uuid4().int

    def __init_subclass__(cls, **kwargs):
        """
        This method is called when a subclass is created.
        It ensures that the parent __post_init__ method is not overridden in subclasses.
        """

        if hasattr(super, "__init_subclass__"):
            super().__init_subclass__(**kwargs)

        if "__post_init__" in cls.__dict__:
            original__post_init__ = cls.__post_init__

            @functools.wraps(original__post_init__)
            def wrapped_post_init(cls):
                # Calls the parent class's __post_init__ method
                if hasattr(super(), "__post_init__"):
                    super().__post__init__()
                # Calls the child __post_init__ method
                original__post_init__(cls)

            cls.__post_init__ = wrapped_post_init

    def _checks(self) -> None:
        """
        Perform checks on the model attributes to ensure they are valid.
        This method cannot be overridden in subclasses for specific checks.
        """
        if self.status not in ["Active", "Draft", "Archived"]:
            raise ValueError("Invalid model status.")
        if self.type != "OLS":
            raise ValueError("Unsupported model type. Only 'OLS' is supported.")
        # if self.train.empty():
        #     raise ValueError("Train data cannot be empty.")
        # if self.forecasts.empty():
        #     raise ValueError("Forecast data cannot be empty at model creation.")

        # # Check if the data has an index set
        # if self.train.index is None:
        #     raise ValueError("Train data must have an index set.")
        # if (self.test.empty is not False) and (self.test.index is None):
        #     raise ValueError("Test data must have an index set if provided.")

        # # Check if the exog and endog are in the data provided
        # if self.exog not in self.train.columns or self.endog not in self.train.columns:
        #     raise ValueError(
        #         f"Exogenous variable '{self.exog}' or endogenous variable '{self.endog}' not found in train data."
        #     )
        # if self.test is not None and (
        #     self.exog not in self.test.columns or self.endog not in self.test.columns
        # ):
        #     raise ValueError(
        #         f"Exogenous variable '{self.exog}' or endogenous variable '{self.endog}' not found in test data."
        #     )
        # if self.forecasts is not None and (
        #     self.exog not in self.forecasts.columns
        #     or self.endog not in self.forecasts.columns
        # ):
        #     raise ValueError(
        #         f"Exogenous variable '{self.exog}' or endogenous variable '{self.endog}' not found in forecast data."
        #     )

    def train(self) -> None:
        raise NotImplementedError("Fitting method should be implemented!")

    def test(self) -> None:
        raise NotImplementedError("Testing method should be implemented!")

    def predict(self) -> None:
        raise NotImplementedError("Predicting methods should be implemented!")

    def as_dict(self) -> dict:
        """
        Convert the model to a dictionary.
        This method is useful for serialization or database storage.
        """
        return {
            "name": self.name,
            "version": self.version,
            "owner": self.owner,
            "status": self.status,
            "type": self.type,
            "calibration_date": self.calibration_date,
            "description": self.description,
            "exog": self.exog,
            "endog": self.endog,
            "train_interval": self.train_interval,
            "test_interval": self.test_interval,
            "predict_interval": self.predict_interval,
            "ref_train": self.ref_train,
            "ref_test": self.ref_test,
            "ref_forecast": self.ref_forecast,
            "ref_prediction": self.ref_prediction,
            "id": self.id,
        }
