from dataclasses import dataclass
import pandas as pd
from statsmodels.regression.linear_model import OLSResults, OLS
from statsmodels.tools.tools import add_constant
from moonlight.database.struct_train_data import TrainData
from moonlight.database.struct_test_data import TestData

from moonlight.database.struct_forecast_data import ForecastsData
from moonlight.database.struct_prediction_data import PredictionData
from moonlight.database.struct_results_data import TestResults
from moonlight.database.struct_base import BaseModel


@dataclass
class OLSModel(BaseModel):
    """
    Represents a wage model with various attributes.
    """

    model: OLSResults | None = None

    def train(self, train: TrainData) -> None:
        """
        Estimate the model if it is not already fitted.
        """
        # Check if the model is not fitted and no model path is provided
        if self.model is None:
            self.model = OLS(
                endog=train.data[self.endog],
                exog=add_constant(train.data[self.exog]),
            ).fit()

        if self.ref_train is None:
            self.ref_train = train.id

    def test(self, test: TestData) -> TestResults:
        # TODO: Implement self.ref_test.append(test.id) and return TestResults
        raise NotImplementedError("Testing method is not implemented for OLSModel.")

    def predict(self, forecast: ForecastsData) -> PredictionData:
        """
        Predict using the fitted model.
        """
        if self.model is None:
            raise ValueError(
                "Model is not fitted yet. Please fit the model before predicting."
            )

        # Generate predictions
        predictions = self.model.predict(add_constant(forecast.data))

        # Create ForecastsData object
        prediction_data = PredictionData(
            name="OLS model Forecasts",
            version=self.version,
            owner=self.owner,
            description="Forecasts generated by the OLS model.",
            status=self.status,
            creation_date=str(pd.Timestamp.now()),
            data=predictions,
            index=(str(forecast.data.index.min()), str(forecast.data.index.max())),
        )

        if prediction_data.id not in self.ref_prediction:
            self.ref_prediction.append(prediction_data.id)
        if forecast.id not in self.ref_forecast:
            self.ref_forecast.append(forecast.id)
        return prediction_data

    def __str__(self) -> str:
        """
        Returns a string representation of the WageModel instance.
        """
        return f"{self.__class__.__name__}(model_id={self.model_id}, model_version={self.model_version}, model_owner={self.model_owner}, model_description={self.model_description}, model_status={self.model_status}, model_type={self.model_type})"
